-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Dphones.Mutation exposing (..)

import Dphones.InputObject
import Dphones.Interface
import Dphones.Object
import Dphones.Scalar
import Dphones.ScalarCodecs
import Dphones.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias DeleteAlbumRequiredArguments =
    { where_ : Dphones.InputObject.Album_bool_exp }


{-| delete data from the table: "album"

  - where\_ - filter the rows which have to be deleted

-}
delete_album :
    DeleteAlbumRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Album_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_album requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_album" [ Argument.required "where" requiredArgs____.where_ Dphones.InputObject.encodeAlbum_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteAlbumByPkRequiredArguments =
    { tag : String }


{-| delete single row from the table: "album"
-}
delete_album_by_pk :
    DeleteAlbumByPkRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Album
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_album_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_album_by_pk" [ Argument.required "tag" requiredArgs____.tag Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteMixenRequiredArguments =
    { where_ : Dphones.InputObject.Mixen_bool_exp }


{-| delete data from the table: "mixen"

  - where\_ - filter the rows which have to be deleted

-}
delete_mixen :
    DeleteMixenRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_mixen requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_mixen" [ Argument.required "where" requiredArgs____.where_ Dphones.InputObject.encodeMixen_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteMixenByPkRequiredArguments =
    { url : String }


{-| delete single row from the table: "mixen"
-}
delete_mixen_by_pk :
    DeleteMixenByPkRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_mixen_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_mixen_by_pk" [ Argument.required "url" requiredArgs____.url Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteSetRequiredArguments =
    { where_ : Dphones.InputObject.Set_bool_exp }


{-| delete data from the table: "set"

  - where\_ - filter the rows which have to be deleted

-}
delete_set :
    DeleteSetRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_set requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_set" [ Argument.required "where" requiredArgs____.where_ Dphones.InputObject.encodeSet_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteSetByPkRequiredArguments =
    { tag : String }


{-| delete single row from the table: "set"
-}
delete_set_by_pk :
    DeleteSetByPkRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_set_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_set_by_pk" [ Argument.required "tag" requiredArgs____.tag Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteTrackRequiredArguments =
    { where_ : Dphones.InputObject.Track_bool_exp }


{-| delete data from the table: "track"

  - where\_ - filter the rows which have to be deleted

-}
delete_track :
    DeleteTrackRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Track_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_track requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_track" [ Argument.required "where" requiredArgs____.where_ Dphones.InputObject.encodeTrack_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteTrackByPkRequiredArguments =
    { url : String }


{-| delete single row from the table: "track"
-}
delete_track_by_pk :
    DeleteTrackByPkRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Track
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_track_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_track_by_pk" [ Argument.required "url" requiredArgs____.url Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias InsertAlbumOptionalArguments =
    { on_conflict : OptionalArgument Dphones.InputObject.Album_on_conflict }


type alias InsertAlbumRequiredArguments =
    { objects : List Dphones.InputObject.Album_insert_input }


{-| insert data into the table: "album"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_album :
    (InsertAlbumOptionalArguments -> InsertAlbumOptionalArguments)
    -> InsertAlbumRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Album_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_album fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Dphones.InputObject.encodeAlbum_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_album" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Dphones.InputObject.encodeAlbum_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertAlbumOneOptionalArguments =
    { on_conflict : OptionalArgument Dphones.InputObject.Album_on_conflict }


type alias InsertAlbumOneRequiredArguments =
    { object : Dphones.InputObject.Album_insert_input }


{-| insert a single row into the table: "album"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_album_one :
    (InsertAlbumOneOptionalArguments -> InsertAlbumOneOptionalArguments)
    -> InsertAlbumOneRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Album
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_album_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Dphones.InputObject.encodeAlbum_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_album_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Dphones.InputObject.encodeAlbum_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertMixenOptionalArguments =
    { on_conflict : OptionalArgument Dphones.InputObject.Mixen_on_conflict }


type alias InsertMixenRequiredArguments =
    { objects : List Dphones.InputObject.Mixen_insert_input }


{-| insert data into the table: "mixen"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_mixen :
    (InsertMixenOptionalArguments -> InsertMixenOptionalArguments)
    -> InsertMixenRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_mixen fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Dphones.InputObject.encodeMixen_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_mixen" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Dphones.InputObject.encodeMixen_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertMixenOneOptionalArguments =
    { on_conflict : OptionalArgument Dphones.InputObject.Mixen_on_conflict }


type alias InsertMixenOneRequiredArguments =
    { object : Dphones.InputObject.Mixen_insert_input }


{-| insert a single row into the table: "mixen"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_mixen_one :
    (InsertMixenOneOptionalArguments -> InsertMixenOneOptionalArguments)
    -> InsertMixenOneRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_mixen_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Dphones.InputObject.encodeMixen_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_mixen_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Dphones.InputObject.encodeMixen_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertSetOptionalArguments =
    { on_conflict : OptionalArgument Dphones.InputObject.Set_on_conflict }


type alias InsertSetRequiredArguments =
    { objects : List Dphones.InputObject.Set_insert_input }


{-| insert data into the table: "set"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_set :
    (InsertSetOptionalArguments -> InsertSetOptionalArguments)
    -> InsertSetRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_set fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Dphones.InputObject.encodeSet_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_set" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Dphones.InputObject.encodeSet_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertSetOneOptionalArguments =
    { on_conflict : OptionalArgument Dphones.InputObject.Set_on_conflict }


type alias InsertSetOneRequiredArguments =
    { object : Dphones.InputObject.Set_insert_input }


{-| insert a single row into the table: "set"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_set_one :
    (InsertSetOneOptionalArguments -> InsertSetOneOptionalArguments)
    -> InsertSetOneRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_set_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Dphones.InputObject.encodeSet_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_set_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Dphones.InputObject.encodeSet_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertTrackOptionalArguments =
    { on_conflict : OptionalArgument Dphones.InputObject.Track_on_conflict }


type alias InsertTrackRequiredArguments =
    { objects : List Dphones.InputObject.Track_insert_input }


{-| insert data into the table: "track"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_track :
    (InsertTrackOptionalArguments -> InsertTrackOptionalArguments)
    -> InsertTrackRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Track_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_track fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Dphones.InputObject.encodeTrack_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_track" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Dphones.InputObject.encodeTrack_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertTrackOneOptionalArguments =
    { on_conflict : OptionalArgument Dphones.InputObject.Track_on_conflict }


type alias InsertTrackOneRequiredArguments =
    { object : Dphones.InputObject.Track_insert_input }


{-| insert a single row into the table: "track"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_track_one :
    (InsertTrackOneOptionalArguments -> InsertTrackOneOptionalArguments)
    -> InsertTrackOneRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Track
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_track_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Dphones.InputObject.encodeTrack_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_track_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Dphones.InputObject.encodeTrack_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateAlbumOptionalArguments =
    { set_ : OptionalArgument Dphones.InputObject.Album_set_input }


type alias UpdateAlbumRequiredArguments =
    { where_ : Dphones.InputObject.Album_bool_exp }


{-| update data of the table: "album"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_album :
    (UpdateAlbumOptionalArguments -> UpdateAlbumOptionalArguments)
    -> UpdateAlbumRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Album_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_album fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Dphones.InputObject.encodeAlbum_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_album" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Dphones.InputObject.encodeAlbum_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateAlbumByPkOptionalArguments =
    { set_ : OptionalArgument Dphones.InputObject.Album_set_input }


type alias UpdateAlbumByPkRequiredArguments =
    { pk_columns : Dphones.InputObject.Album_pk_columns_input }


{-| update single row of the table: "album"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_album_by_pk :
    (UpdateAlbumByPkOptionalArguments -> UpdateAlbumByPkOptionalArguments)
    -> UpdateAlbumByPkRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Album
    -> SelectionSet (Maybe decodesTo) RootMutation
update_album_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Dphones.InputObject.encodeAlbum_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_album_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Dphones.InputObject.encodeAlbum_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateAlbumManyRequiredArguments =
    { updates : List Dphones.InputObject.Album_updates }


{-| update multiples rows of table: "album"

  - updates - updates to execute, in order

-}
update_album_many :
    UpdateAlbumManyRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Album_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_album_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_album_many" [ Argument.required "updates" requiredArgs____.updates (Dphones.InputObject.encodeAlbum_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateMixenOptionalArguments =
    { inc_ : OptionalArgument Dphones.InputObject.Mixen_inc_input
    , set_ : OptionalArgument Dphones.InputObject.Mixen_set_input
    }


type alias UpdateMixenRequiredArguments =
    { where_ : Dphones.InputObject.Mixen_bool_exp }


{-| update data of the table: "mixen"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_mixen :
    (UpdateMixenOptionalArguments -> UpdateMixenOptionalArguments)
    -> UpdateMixenRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_mixen fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ Dphones.InputObject.encodeMixen_inc_input, Argument.optional "_set" filledInOptionals____.set_ Dphones.InputObject.encodeMixen_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_mixen" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Dphones.InputObject.encodeMixen_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateMixenByPkOptionalArguments =
    { inc_ : OptionalArgument Dphones.InputObject.Mixen_inc_input
    , set_ : OptionalArgument Dphones.InputObject.Mixen_set_input
    }


type alias UpdateMixenByPkRequiredArguments =
    { pk_columns : Dphones.InputObject.Mixen_pk_columns_input }


{-| update single row of the table: "mixen"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_mixen_by_pk :
    (UpdateMixenByPkOptionalArguments -> UpdateMixenByPkOptionalArguments)
    -> UpdateMixenByPkRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen
    -> SelectionSet (Maybe decodesTo) RootMutation
update_mixen_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ Dphones.InputObject.encodeMixen_inc_input, Argument.optional "_set" filledInOptionals____.set_ Dphones.InputObject.encodeMixen_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_mixen_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Dphones.InputObject.encodeMixen_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateMixenManyRequiredArguments =
    { updates : List Dphones.InputObject.Mixen_updates }


{-| update multiples rows of table: "mixen"

  - updates - updates to execute, in order

-}
update_mixen_many :
    UpdateMixenManyRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_mixen_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_mixen_many" [ Argument.required "updates" requiredArgs____.updates (Dphones.InputObject.encodeMixen_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateSetOptionalArguments =
    { set_ : OptionalArgument Dphones.InputObject.Set_set_input }


type alias UpdateSetRequiredArguments =
    { where_ : Dphones.InputObject.Set_bool_exp }


{-| update data of the table: "set"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_set :
    (UpdateSetOptionalArguments -> UpdateSetOptionalArguments)
    -> UpdateSetRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_set fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Dphones.InputObject.encodeSet_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_set" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Dphones.InputObject.encodeSet_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateSetByPkOptionalArguments =
    { set_ : OptionalArgument Dphones.InputObject.Set_set_input }


type alias UpdateSetByPkRequiredArguments =
    { pk_columns : Dphones.InputObject.Set_pk_columns_input }


{-| update single row of the table: "set"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_set_by_pk :
    (UpdateSetByPkOptionalArguments -> UpdateSetByPkOptionalArguments)
    -> UpdateSetByPkRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set
    -> SelectionSet (Maybe decodesTo) RootMutation
update_set_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Dphones.InputObject.encodeSet_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_set_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Dphones.InputObject.encodeSet_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateSetManyRequiredArguments =
    { updates : List Dphones.InputObject.Set_updates }


{-| update multiples rows of table: "set"

  - updates - updates to execute, in order

-}
update_set_many :
    UpdateSetManyRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_set_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_set_many" [ Argument.required "updates" requiredArgs____.updates (Dphones.InputObject.encodeSet_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateTrackOptionalArguments =
    { inc_ : OptionalArgument Dphones.InputObject.Track_inc_input
    , set_ : OptionalArgument Dphones.InputObject.Track_set_input
    }


type alias UpdateTrackRequiredArguments =
    { where_ : Dphones.InputObject.Track_bool_exp }


{-| update data of the table: "track"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_track :
    (UpdateTrackOptionalArguments -> UpdateTrackOptionalArguments)
    -> UpdateTrackRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Track_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_track fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ Dphones.InputObject.encodeTrack_inc_input, Argument.optional "_set" filledInOptionals____.set_ Dphones.InputObject.encodeTrack_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_track" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Dphones.InputObject.encodeTrack_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateTrackByPkOptionalArguments =
    { inc_ : OptionalArgument Dphones.InputObject.Track_inc_input
    , set_ : OptionalArgument Dphones.InputObject.Track_set_input
    }


type alias UpdateTrackByPkRequiredArguments =
    { pk_columns : Dphones.InputObject.Track_pk_columns_input }


{-| update single row of the table: "track"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_track_by_pk :
    (UpdateTrackByPkOptionalArguments -> UpdateTrackByPkOptionalArguments)
    -> UpdateTrackByPkRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Track
    -> SelectionSet (Maybe decodesTo) RootMutation
update_track_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ Dphones.InputObject.encodeTrack_inc_input, Argument.optional "_set" filledInOptionals____.set_ Dphones.InputObject.encodeTrack_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_track_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Dphones.InputObject.encodeTrack_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateTrackManyRequiredArguments =
    { updates : List Dphones.InputObject.Track_updates }


{-| update multiples rows of table: "track"

  - updates - updates to execute, in order

-}
update_track_many :
    UpdateTrackManyRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Track_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_track_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_track_many" [ Argument.required "updates" requiredArgs____.updates (Dphones.InputObject.encodeTrack_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)
