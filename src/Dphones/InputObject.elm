-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Dphones.InputObject exposing (..)

import Dphones.Enum.Album_constraint
import Dphones.Enum.Album_update_column
import Dphones.Enum.Cursor_ordering
import Dphones.Enum.Mixen_constraint
import Dphones.Enum.Mixen_select_column
import Dphones.Enum.Mixen_update_column
import Dphones.Enum.Order_by
import Dphones.Enum.Set_constraint
import Dphones.Enum.Set_update_column
import Dphones.Enum.Track_constraint
import Dphones.Enum.Track_select_column
import Dphones.Enum.Track_update_column
import Dphones.Interface
import Dphones.Object
import Dphones.Scalar
import Dphones.ScalarCodecs
import Dphones.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildAlbum_bool_exp :
    (Album_bool_expOptionalFields -> Album_bool_expOptionalFields)
    -> Album_bool_exp
buildAlbum_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, date = Absent, lists = Absent, lists_aggregate = Absent, tag = Absent, title = Absent }
    in
    Album_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, date = optionals____.date, lists = optionals____.lists, lists_aggregate = optionals____.lists_aggregate, tag = optionals____.tag, title = optionals____.title }


type alias Album_bool_expOptionalFields =
    { and_ : OptionalArgument (List Album_bool_exp)
    , not_ : OptionalArgument Album_bool_exp
    , or_ : OptionalArgument (List Album_bool_exp)
    , date : OptionalArgument Date_comparison_exp
    , lists : OptionalArgument Track_bool_exp
    , lists_aggregate : OptionalArgument Track_aggregate_bool_exp
    , tag : OptionalArgument String_comparison_exp
    , title : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Album_bool_exp` attributes. Note that this type
needs to use the `Album_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Album_bool_expRaw =
    { and_ : OptionalArgument (List Album_bool_exp)
    , not_ : OptionalArgument Album_bool_exp
    , or_ : OptionalArgument (List Album_bool_exp)
    , date : OptionalArgument Date_comparison_exp
    , lists : OptionalArgument Track_bool_exp
    , lists_aggregate : OptionalArgument Track_aggregate_bool_exp
    , tag : OptionalArgument String_comparison_exp
    , title : OptionalArgument String_comparison_exp
    }


{-| Type for the Album\_bool\_exp input object.
-}
type Album_bool_exp
    = Album_bool_exp Album_bool_expRaw


{-| Encode a Album\_bool\_exp into a value that can be used as an argument.
-}
encodeAlbum_bool_exp : Album_bool_exp -> Value
encodeAlbum_bool_exp (Album_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeAlbum_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeAlbum_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeAlbum_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "date", encodeDate_comparison_exp |> Encode.optional input____.date ), ( "lists", encodeTrack_bool_exp |> Encode.optional input____.lists ), ( "lists_aggregate", encodeTrack_aggregate_bool_exp |> Encode.optional input____.lists_aggregate ), ( "tag", encodeString_comparison_exp |> Encode.optional input____.tag ), ( "title", encodeString_comparison_exp |> Encode.optional input____.title ) ]


buildAlbum_insert_input :
    (Album_insert_inputOptionalFields -> Album_insert_inputOptionalFields)
    -> Album_insert_input
buildAlbum_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { date = Absent, lists = Absent, tag = Absent, title = Absent }
    in
    Album_insert_input { date = optionals____.date, lists = optionals____.lists, tag = optionals____.tag, title = optionals____.title }


type alias Album_insert_inputOptionalFields =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , lists : OptionalArgument Track_arr_rel_insert_input
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type alias for the `Album_insert_input` attributes. Note that this type
needs to use the `Album_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Album_insert_inputRaw =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , lists : OptionalArgument Track_arr_rel_insert_input
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type for the Album\_insert\_input input object.
-}
type Album_insert_input
    = Album_insert_input Album_insert_inputRaw


{-| Encode a Album\_insert\_input into a value that can be used as an argument.
-}
encodeAlbum_insert_input : Album_insert_input -> Value
encodeAlbum_insert_input (Album_insert_input input____) =
    Encode.maybeObject
        [ ( "date", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.date ), ( "lists", encodeTrack_arr_rel_insert_input |> Encode.optional input____.lists ), ( "tag", Encode.string |> Encode.optional input____.tag ), ( "title", Encode.string |> Encode.optional input____.title ) ]


buildAlbum_obj_rel_insert_input :
    Album_obj_rel_insert_inputRequiredFields
    -> (Album_obj_rel_insert_inputOptionalFields -> Album_obj_rel_insert_inputOptionalFields)
    -> Album_obj_rel_insert_input
buildAlbum_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Album_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Album_obj_rel_insert_inputRequiredFields =
    { data : Album_insert_input }


type alias Album_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Album_on_conflict }


{-| Type alias for the `Album_obj_rel_insert_input` attributes. Note that this type
needs to use the `Album_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Album_obj_rel_insert_inputRaw =
    { data : Album_insert_input
    , on_conflict : OptionalArgument Album_on_conflict
    }


{-| Type for the Album\_obj\_rel\_insert\_input input object.
-}
type Album_obj_rel_insert_input
    = Album_obj_rel_insert_input Album_obj_rel_insert_inputRaw


{-| Encode a Album\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeAlbum_obj_rel_insert_input : Album_obj_rel_insert_input -> Value
encodeAlbum_obj_rel_insert_input (Album_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeAlbum_insert_input input____.data |> Just ), ( "on_conflict", encodeAlbum_on_conflict |> Encode.optional input____.on_conflict ) ]


buildAlbum_on_conflict :
    Album_on_conflictRequiredFields
    -> (Album_on_conflictOptionalFields -> Album_on_conflictOptionalFields)
    -> Album_on_conflict
buildAlbum_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Album_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Album_on_conflictRequiredFields =
    { constraint : Dphones.Enum.Album_constraint.Album_constraint
    , update_columns : List Dphones.Enum.Album_update_column.Album_update_column
    }


type alias Album_on_conflictOptionalFields =
    { where_ : OptionalArgument Album_bool_exp }


{-| Type alias for the `Album_on_conflict` attributes. Note that this type
needs to use the `Album_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Album_on_conflictRaw =
    { constraint : Dphones.Enum.Album_constraint.Album_constraint
    , update_columns : List Dphones.Enum.Album_update_column.Album_update_column
    , where_ : OptionalArgument Album_bool_exp
    }


{-| Type for the Album\_on\_conflict input object.
-}
type Album_on_conflict
    = Album_on_conflict Album_on_conflictRaw


{-| Encode a Album\_on\_conflict into a value that can be used as an argument.
-}
encodeAlbum_on_conflict : Album_on_conflict -> Value
encodeAlbum_on_conflict (Album_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Dphones.Enum.Album_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Dphones.Enum.Album_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeAlbum_bool_exp |> Encode.optional input____.where_ ) ]


buildAlbum_order_by :
    (Album_order_byOptionalFields -> Album_order_byOptionalFields)
    -> Album_order_by
buildAlbum_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { date = Absent, lists_aggregate = Absent, tag = Absent, title = Absent }
    in
    { date = optionals____.date, lists_aggregate = optionals____.lists_aggregate, tag = optionals____.tag, title = optionals____.title }


type alias Album_order_byOptionalFields =
    { date : OptionalArgument Dphones.Enum.Order_by.Order_by
    , lists_aggregate : OptionalArgument Track_aggregate_order_by
    , tag : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Album\_order\_by input object.
-}
type alias Album_order_by =
    { date : OptionalArgument Dphones.Enum.Order_by.Order_by
    , lists_aggregate : OptionalArgument Track_aggregate_order_by
    , tag : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Album\_order\_by into a value that can be used as an argument.
-}
encodeAlbum_order_by : Album_order_by -> Value
encodeAlbum_order_by input____ =
    Encode.maybeObject
        [ ( "date", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.date ), ( "lists_aggregate", encodeTrack_aggregate_order_by |> Encode.optional input____.lists_aggregate ), ( "tag", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.tag ), ( "title", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.title ) ]


buildAlbum_pk_columns_input :
    Album_pk_columns_inputRequiredFields
    -> Album_pk_columns_input
buildAlbum_pk_columns_input required____ =
    { tag = required____.tag }


type alias Album_pk_columns_inputRequiredFields =
    { tag : String }


{-| Type for the Album\_pk\_columns\_input input object.
-}
type alias Album_pk_columns_input =
    { tag : String }


{-| Encode a Album\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeAlbum_pk_columns_input : Album_pk_columns_input -> Value
encodeAlbum_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "tag", Encode.string input____.tag |> Just ) ]


buildAlbum_set_input :
    (Album_set_inputOptionalFields -> Album_set_inputOptionalFields)
    -> Album_set_input
buildAlbum_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { date = Absent, tag = Absent, title = Absent }
    in
    { date = optionals____.date, tag = optionals____.tag, title = optionals____.title }


type alias Album_set_inputOptionalFields =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type for the Album\_set\_input input object.
-}
type alias Album_set_input =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Encode a Album\_set\_input into a value that can be used as an argument.
-}
encodeAlbum_set_input : Album_set_input -> Value
encodeAlbum_set_input input____ =
    Encode.maybeObject
        [ ( "date", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.date ), ( "tag", Encode.string |> Encode.optional input____.tag ), ( "title", Encode.string |> Encode.optional input____.title ) ]


buildAlbum_stream_cursor_input :
    Album_stream_cursor_inputRequiredFields
    -> (Album_stream_cursor_inputOptionalFields -> Album_stream_cursor_inputOptionalFields)
    -> Album_stream_cursor_input
buildAlbum_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Album_stream_cursor_inputRequiredFields =
    { initial_value : Album_stream_cursor_value_input }


type alias Album_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Dphones.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Album\_stream\_cursor\_input input object.
-}
type alias Album_stream_cursor_input =
    { initial_value : Album_stream_cursor_value_input
    , ordering : OptionalArgument Dphones.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Album\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeAlbum_stream_cursor_input : Album_stream_cursor_input -> Value
encodeAlbum_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeAlbum_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Dphones.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildAlbum_stream_cursor_value_input :
    (Album_stream_cursor_value_inputOptionalFields -> Album_stream_cursor_value_inputOptionalFields)
    -> Album_stream_cursor_value_input
buildAlbum_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { date = Absent, tag = Absent, title = Absent }
    in
    { date = optionals____.date, tag = optionals____.tag, title = optionals____.title }


type alias Album_stream_cursor_value_inputOptionalFields =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type for the Album\_stream\_cursor\_value\_input input object.
-}
type alias Album_stream_cursor_value_input =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Encode a Album\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeAlbum_stream_cursor_value_input : Album_stream_cursor_value_input -> Value
encodeAlbum_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "date", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.date ), ( "tag", Encode.string |> Encode.optional input____.tag ), ( "title", Encode.string |> Encode.optional input____.title ) ]


buildAlbum_updates :
    Album_updatesRequiredFields
    -> (Album_updatesOptionalFields -> Album_updatesOptionalFields)
    -> Album_updates
buildAlbum_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Album_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Album_updatesRequiredFields =
    { where_ : Album_bool_exp }


type alias Album_updatesOptionalFields =
    { set_ : OptionalArgument Album_set_input }


{-| Type alias for the `Album_updates` attributes. Note that this type
needs to use the `Album_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Album_updatesRaw =
    { set_ : OptionalArgument Album_set_input
    , where_ : Album_bool_exp
    }


{-| Type for the Album\_updates input object.
-}
type Album_updates
    = Album_updates Album_updatesRaw


{-| Encode a Album\_updates into a value that can be used as an argument.
-}
encodeAlbum_updates : Album_updates -> Value
encodeAlbum_updates (Album_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeAlbum_set_input |> Encode.optional input____.set_ ), ( "where", encodeAlbum_bool_exp input____.where_ |> Just ) ]


buildDate_comparison_exp :
    (Date_comparison_expOptionalFields -> Date_comparison_expOptionalFields)
    -> Date_comparison_exp
buildDate_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Date_comparison_expOptionalFields =
    { eq_ : OptionalArgument Dphones.ScalarCodecs.Date
    , gt_ : OptionalArgument Dphones.ScalarCodecs.Date
    , gte_ : OptionalArgument Dphones.ScalarCodecs.Date
    , in_ : OptionalArgument (List Dphones.ScalarCodecs.Date)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Dphones.ScalarCodecs.Date
    , lte_ : OptionalArgument Dphones.ScalarCodecs.Date
    , neq_ : OptionalArgument Dphones.ScalarCodecs.Date
    , nin_ : OptionalArgument (List Dphones.ScalarCodecs.Date)
    }


{-| Type for the Date\_comparison\_exp input object.
-}
type alias Date_comparison_exp =
    { eq_ : OptionalArgument Dphones.ScalarCodecs.Date
    , gt_ : OptionalArgument Dphones.ScalarCodecs.Date
    , gte_ : OptionalArgument Dphones.ScalarCodecs.Date
    , in_ : OptionalArgument (List Dphones.ScalarCodecs.Date)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Dphones.ScalarCodecs.Date
    , lte_ : OptionalArgument Dphones.ScalarCodecs.Date
    , neq_ : OptionalArgument Dphones.ScalarCodecs.Date
    , nin_ : OptionalArgument (List Dphones.ScalarCodecs.Date)
    }


{-| Encode a Date\_comparison\_exp into a value that can be used as an argument.
-}
encodeDate_comparison_exp : Date_comparison_exp -> Value
encodeDate_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.eq_ ), ( "_gt", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.gt_ ), ( "_gte", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.gte_ ), ( "_in", ((Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.lt_ ), ( "_lte", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.lte_ ), ( "_neq", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.neq_ ), ( "_nin", ((Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildInt_comparison_exp :
    (Int_comparison_expOptionalFields -> Int_comparison_expOptionalFields)
    -> Int_comparison_exp
buildInt_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Int_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Int\_comparison\_exp input object.
-}
type alias Int_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Int\_comparison\_exp into a value that can be used as an argument.
-}
encodeInt_comparison_exp : Int_comparison_exp -> Value
encodeInt_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input____.eq_ ), ( "_gt", Encode.int |> Encode.optional input____.gt_ ), ( "_gte", Encode.int |> Encode.optional input____.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", Encode.int |> Encode.optional input____.lt_ ), ( "_lte", Encode.int |> Encode.optional input____.lte_ ), ( "_neq", Encode.int |> Encode.optional input____.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildMixen_aggregate_bool_exp :
    (Mixen_aggregate_bool_expOptionalFields -> Mixen_aggregate_bool_expOptionalFields)
    -> Mixen_aggregate_bool_exp
buildMixen_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Mixen_aggregate_bool_exp { count = optionals____.count }


type alias Mixen_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Mixen_aggregate_bool_exp_count }


{-| Type alias for the `Mixen_aggregate_bool_exp` attributes. Note that this type
needs to use the `Mixen_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Mixen_aggregate_bool_expRaw =
    { count : OptionalArgument Mixen_aggregate_bool_exp_count }


{-| Type for the Mixen\_aggregate\_bool\_exp input object.
-}
type Mixen_aggregate_bool_exp
    = Mixen_aggregate_bool_exp Mixen_aggregate_bool_expRaw


{-| Encode a Mixen\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeMixen_aggregate_bool_exp : Mixen_aggregate_bool_exp -> Value
encodeMixen_aggregate_bool_exp (Mixen_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeMixen_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildMixen_aggregate_bool_exp_count :
    Mixen_aggregate_bool_exp_countRequiredFields
    -> (Mixen_aggregate_bool_exp_countOptionalFields -> Mixen_aggregate_bool_exp_countOptionalFields)
    -> Mixen_aggregate_bool_exp_count
buildMixen_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Mixen_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Mixen_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Mixen_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List Dphones.Enum.Mixen_select_column.Mixen_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Mixen_bool_exp
    }


{-| Type alias for the `Mixen_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Mixen_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Mixen_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List Dphones.Enum.Mixen_select_column.Mixen_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Mixen_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Mixen\_aggregate\_bool\_exp\_count input object.
-}
type Mixen_aggregate_bool_exp_count
    = Mixen_aggregate_bool_exp_count Mixen_aggregate_bool_exp_countRaw


{-| Encode a Mixen\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeMixen_aggregate_bool_exp_count : Mixen_aggregate_bool_exp_count -> Value
encodeMixen_aggregate_bool_exp_count (Mixen_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum Dphones.Enum.Mixen_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeMixen_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildMixen_aggregate_order_by :
    (Mixen_aggregate_order_byOptionalFields -> Mixen_aggregate_order_byOptionalFields)
    -> Mixen_aggregate_order_by
buildMixen_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals____.avg, count = optionals____.count, max = optionals____.max, min = optionals____.min, stddev = optionals____.stddev, stddev_pop = optionals____.stddev_pop, stddev_samp = optionals____.stddev_samp, sum = optionals____.sum, var_pop = optionals____.var_pop, var_samp = optionals____.var_samp, variance = optionals____.variance }


type alias Mixen_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Mixen_avg_order_by
    , count : OptionalArgument Dphones.Enum.Order_by.Order_by
    , max : OptionalArgument Mixen_max_order_by
    , min : OptionalArgument Mixen_min_order_by
    , stddev : OptionalArgument Mixen_stddev_order_by
    , stddev_pop : OptionalArgument Mixen_stddev_pop_order_by
    , stddev_samp : OptionalArgument Mixen_stddev_samp_order_by
    , sum : OptionalArgument Mixen_sum_order_by
    , var_pop : OptionalArgument Mixen_var_pop_order_by
    , var_samp : OptionalArgument Mixen_var_samp_order_by
    , variance : OptionalArgument Mixen_variance_order_by
    }


{-| Type for the Mixen\_aggregate\_order\_by input object.
-}
type alias Mixen_aggregate_order_by =
    { avg : OptionalArgument Mixen_avg_order_by
    , count : OptionalArgument Dphones.Enum.Order_by.Order_by
    , max : OptionalArgument Mixen_max_order_by
    , min : OptionalArgument Mixen_min_order_by
    , stddev : OptionalArgument Mixen_stddev_order_by
    , stddev_pop : OptionalArgument Mixen_stddev_pop_order_by
    , stddev_samp : OptionalArgument Mixen_stddev_samp_order_by
    , sum : OptionalArgument Mixen_sum_order_by
    , var_pop : OptionalArgument Mixen_var_pop_order_by
    , var_samp : OptionalArgument Mixen_var_samp_order_by
    , variance : OptionalArgument Mixen_variance_order_by
    }


{-| Encode a Mixen\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeMixen_aggregate_order_by : Mixen_aggregate_order_by -> Value
encodeMixen_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "avg", encodeMixen_avg_order_by |> Encode.optional input____.avg ), ( "count", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeMixen_max_order_by |> Encode.optional input____.max ), ( "min", encodeMixen_min_order_by |> Encode.optional input____.min ), ( "stddev", encodeMixen_stddev_order_by |> Encode.optional input____.stddev ), ( "stddev_pop", encodeMixen_stddev_pop_order_by |> Encode.optional input____.stddev_pop ), ( "stddev_samp", encodeMixen_stddev_samp_order_by |> Encode.optional input____.stddev_samp ), ( "sum", encodeMixen_sum_order_by |> Encode.optional input____.sum ), ( "var_pop", encodeMixen_var_pop_order_by |> Encode.optional input____.var_pop ), ( "var_samp", encodeMixen_var_samp_order_by |> Encode.optional input____.var_samp ), ( "variance", encodeMixen_variance_order_by |> Encode.optional input____.variance ) ]


buildMixen_arr_rel_insert_input :
    Mixen_arr_rel_insert_inputRequiredFields
    -> (Mixen_arr_rel_insert_inputOptionalFields -> Mixen_arr_rel_insert_inputOptionalFields)
    -> Mixen_arr_rel_insert_input
buildMixen_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Mixen_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Mixen_arr_rel_insert_inputRequiredFields =
    { data : List Mixen_insert_input }


type alias Mixen_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Mixen_on_conflict }


{-| Type alias for the `Mixen_arr_rel_insert_input` attributes. Note that this type
needs to use the `Mixen_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Mixen_arr_rel_insert_inputRaw =
    { data : List Mixen_insert_input
    , on_conflict : OptionalArgument Mixen_on_conflict
    }


{-| Type for the Mixen\_arr\_rel\_insert\_input input object.
-}
type Mixen_arr_rel_insert_input
    = Mixen_arr_rel_insert_input Mixen_arr_rel_insert_inputRaw


{-| Encode a Mixen\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeMixen_arr_rel_insert_input : Mixen_arr_rel_insert_input -> Value
encodeMixen_arr_rel_insert_input (Mixen_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeMixen_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeMixen_on_conflict |> Encode.optional input____.on_conflict ) ]


buildMixen_avg_order_by :
    (Mixen_avg_order_byOptionalFields -> Mixen_avg_order_byOptionalFields)
    -> Mixen_avg_order_by
buildMixen_avg_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Mixen_avg_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Mixen\_avg\_order\_by input object.
-}
type alias Mixen_avg_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Mixen\_avg\_order\_by into a value that can be used as an argument.
-}
encodeMixen_avg_order_by : Mixen_avg_order_by -> Value
encodeMixen_avg_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildMixen_bool_exp :
    (Mixen_bool_expOptionalFields -> Mixen_bool_expOptionalFields)
    -> Mixen_bool_exp
buildMixen_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, belongsTo = Absent, index = Absent, list = Absent, plays = Absent, title = Absent, url = Absent }
    in
    Mixen_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, belongsTo = optionals____.belongsTo, index = optionals____.index, list = optionals____.list, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Mixen_bool_expOptionalFields =
    { and_ : OptionalArgument (List Mixen_bool_exp)
    , not_ : OptionalArgument Mixen_bool_exp
    , or_ : OptionalArgument (List Mixen_bool_exp)
    , belongsTo : OptionalArgument Set_bool_exp
    , index : OptionalArgument Int_comparison_exp
    , list : OptionalArgument String_comparison_exp
    , plays : OptionalArgument Int_comparison_exp
    , title : OptionalArgument String_comparison_exp
    , url : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Mixen_bool_exp` attributes. Note that this type
needs to use the `Mixen_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Mixen_bool_expRaw =
    { and_ : OptionalArgument (List Mixen_bool_exp)
    , not_ : OptionalArgument Mixen_bool_exp
    , or_ : OptionalArgument (List Mixen_bool_exp)
    , belongsTo : OptionalArgument Set_bool_exp
    , index : OptionalArgument Int_comparison_exp
    , list : OptionalArgument String_comparison_exp
    , plays : OptionalArgument Int_comparison_exp
    , title : OptionalArgument String_comparison_exp
    , url : OptionalArgument String_comparison_exp
    }


{-| Type for the Mixen\_bool\_exp input object.
-}
type Mixen_bool_exp
    = Mixen_bool_exp Mixen_bool_expRaw


{-| Encode a Mixen\_bool\_exp into a value that can be used as an argument.
-}
encodeMixen_bool_exp : Mixen_bool_exp -> Value
encodeMixen_bool_exp (Mixen_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeMixen_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeMixen_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeMixen_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "belongsTo", encodeSet_bool_exp |> Encode.optional input____.belongsTo ), ( "index", encodeInt_comparison_exp |> Encode.optional input____.index ), ( "list", encodeString_comparison_exp |> Encode.optional input____.list ), ( "plays", encodeInt_comparison_exp |> Encode.optional input____.plays ), ( "title", encodeString_comparison_exp |> Encode.optional input____.title ), ( "url", encodeString_comparison_exp |> Encode.optional input____.url ) ]


buildMixen_inc_input :
    (Mixen_inc_inputOptionalFields -> Mixen_inc_inputOptionalFields)
    -> Mixen_inc_input
buildMixen_inc_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Mixen_inc_inputOptionalFields =
    { index : OptionalArgument Int
    , plays : OptionalArgument Int
    }


{-| Type for the Mixen\_inc\_input input object.
-}
type alias Mixen_inc_input =
    { index : OptionalArgument Int
    , plays : OptionalArgument Int
    }


{-| Encode a Mixen\_inc\_input into a value that can be used as an argument.
-}
encodeMixen_inc_input : Mixen_inc_input -> Value
encodeMixen_inc_input input____ =
    Encode.maybeObject
        [ ( "index", Encode.int |> Encode.optional input____.index ), ( "plays", Encode.int |> Encode.optional input____.plays ) ]


buildMixen_insert_input :
    (Mixen_insert_inputOptionalFields -> Mixen_insert_inputOptionalFields)
    -> Mixen_insert_input
buildMixen_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { belongsTo = Absent, index = Absent, list = Absent, plays = Absent, title = Absent, url = Absent }
    in
    Mixen_insert_input { belongsTo = optionals____.belongsTo, index = optionals____.index, list = optionals____.list, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Mixen_insert_inputOptionalFields =
    { belongsTo : OptionalArgument Set_obj_rel_insert_input
    , index : OptionalArgument Int
    , list : OptionalArgument String
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Type alias for the `Mixen_insert_input` attributes. Note that this type
needs to use the `Mixen_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Mixen_insert_inputRaw =
    { belongsTo : OptionalArgument Set_obj_rel_insert_input
    , index : OptionalArgument Int
    , list : OptionalArgument String
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Type for the Mixen\_insert\_input input object.
-}
type Mixen_insert_input
    = Mixen_insert_input Mixen_insert_inputRaw


{-| Encode a Mixen\_insert\_input into a value that can be used as an argument.
-}
encodeMixen_insert_input : Mixen_insert_input -> Value
encodeMixen_insert_input (Mixen_insert_input input____) =
    Encode.maybeObject
        [ ( "belongsTo", encodeSet_obj_rel_insert_input |> Encode.optional input____.belongsTo ), ( "index", Encode.int |> Encode.optional input____.index ), ( "list", Encode.string |> Encode.optional input____.list ), ( "plays", Encode.int |> Encode.optional input____.plays ), ( "title", Encode.string |> Encode.optional input____.title ), ( "url", Encode.string |> Encode.optional input____.url ) ]


buildMixen_max_order_by :
    (Mixen_max_order_byOptionalFields -> Mixen_max_order_byOptionalFields)
    -> Mixen_max_order_by
buildMixen_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, list = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { index = optionals____.index, list = optionals____.list, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Mixen_max_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , list : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Mixen\_max\_order\_by input object.
-}
type alias Mixen_max_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , list : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Mixen\_max\_order\_by into a value that can be used as an argument.
-}
encodeMixen_max_order_by : Mixen_max_order_by -> Value
encodeMixen_max_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "list", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.list ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ), ( "title", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.title ), ( "url", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.url ) ]


buildMixen_min_order_by :
    (Mixen_min_order_byOptionalFields -> Mixen_min_order_byOptionalFields)
    -> Mixen_min_order_by
buildMixen_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, list = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { index = optionals____.index, list = optionals____.list, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Mixen_min_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , list : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Mixen\_min\_order\_by input object.
-}
type alias Mixen_min_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , list : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Mixen\_min\_order\_by into a value that can be used as an argument.
-}
encodeMixen_min_order_by : Mixen_min_order_by -> Value
encodeMixen_min_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "list", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.list ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ), ( "title", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.title ), ( "url", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.url ) ]


buildMixen_on_conflict :
    Mixen_on_conflictRequiredFields
    -> (Mixen_on_conflictOptionalFields -> Mixen_on_conflictOptionalFields)
    -> Mixen_on_conflict
buildMixen_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Mixen_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Mixen_on_conflictRequiredFields =
    { constraint : Dphones.Enum.Mixen_constraint.Mixen_constraint
    , update_columns : List Dphones.Enum.Mixen_update_column.Mixen_update_column
    }


type alias Mixen_on_conflictOptionalFields =
    { where_ : OptionalArgument Mixen_bool_exp }


{-| Type alias for the `Mixen_on_conflict` attributes. Note that this type
needs to use the `Mixen_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Mixen_on_conflictRaw =
    { constraint : Dphones.Enum.Mixen_constraint.Mixen_constraint
    , update_columns : List Dphones.Enum.Mixen_update_column.Mixen_update_column
    , where_ : OptionalArgument Mixen_bool_exp
    }


{-| Type for the Mixen\_on\_conflict input object.
-}
type Mixen_on_conflict
    = Mixen_on_conflict Mixen_on_conflictRaw


{-| Encode a Mixen\_on\_conflict into a value that can be used as an argument.
-}
encodeMixen_on_conflict : Mixen_on_conflict -> Value
encodeMixen_on_conflict (Mixen_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Dphones.Enum.Mixen_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Dphones.Enum.Mixen_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeMixen_bool_exp |> Encode.optional input____.where_ ) ]


buildMixen_order_by :
    (Mixen_order_byOptionalFields -> Mixen_order_byOptionalFields)
    -> Mixen_order_by
buildMixen_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { belongsTo = Absent, index = Absent, list = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { belongsTo = optionals____.belongsTo, index = optionals____.index, list = optionals____.list, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Mixen_order_byOptionalFields =
    { belongsTo : OptionalArgument Set_order_by
    , index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , list : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Mixen\_order\_by input object.
-}
type alias Mixen_order_by =
    { belongsTo : OptionalArgument Set_order_by
    , index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , list : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Mixen\_order\_by into a value that can be used as an argument.
-}
encodeMixen_order_by : Mixen_order_by -> Value
encodeMixen_order_by input____ =
    Encode.maybeObject
        [ ( "belongsTo", encodeSet_order_by |> Encode.optional input____.belongsTo ), ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "list", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.list ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ), ( "title", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.title ), ( "url", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.url ) ]


buildMixen_pk_columns_input :
    Mixen_pk_columns_inputRequiredFields
    -> Mixen_pk_columns_input
buildMixen_pk_columns_input required____ =
    { url = required____.url }


type alias Mixen_pk_columns_inputRequiredFields =
    { url : String }


{-| Type for the Mixen\_pk\_columns\_input input object.
-}
type alias Mixen_pk_columns_input =
    { url : String }


{-| Encode a Mixen\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeMixen_pk_columns_input : Mixen_pk_columns_input -> Value
encodeMixen_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "url", Encode.string input____.url |> Just ) ]


buildMixen_set_input :
    (Mixen_set_inputOptionalFields -> Mixen_set_inputOptionalFields)
    -> Mixen_set_input
buildMixen_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, list = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { index = optionals____.index, list = optionals____.list, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Mixen_set_inputOptionalFields =
    { index : OptionalArgument Int
    , list : OptionalArgument String
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Type for the Mixen\_set\_input input object.
-}
type alias Mixen_set_input =
    { index : OptionalArgument Int
    , list : OptionalArgument String
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Encode a Mixen\_set\_input into a value that can be used as an argument.
-}
encodeMixen_set_input : Mixen_set_input -> Value
encodeMixen_set_input input____ =
    Encode.maybeObject
        [ ( "index", Encode.int |> Encode.optional input____.index ), ( "list", Encode.string |> Encode.optional input____.list ), ( "plays", Encode.int |> Encode.optional input____.plays ), ( "title", Encode.string |> Encode.optional input____.title ), ( "url", Encode.string |> Encode.optional input____.url ) ]


buildMixen_stddev_order_by :
    (Mixen_stddev_order_byOptionalFields -> Mixen_stddev_order_byOptionalFields)
    -> Mixen_stddev_order_by
buildMixen_stddev_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Mixen_stddev_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Mixen\_stddev\_order\_by input object.
-}
type alias Mixen_stddev_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Mixen\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeMixen_stddev_order_by : Mixen_stddev_order_by -> Value
encodeMixen_stddev_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildMixen_stddev_pop_order_by :
    (Mixen_stddev_pop_order_byOptionalFields -> Mixen_stddev_pop_order_byOptionalFields)
    -> Mixen_stddev_pop_order_by
buildMixen_stddev_pop_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Mixen_stddev_pop_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Mixen\_stddev\_pop\_order\_by input object.
-}
type alias Mixen_stddev_pop_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Mixen\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeMixen_stddev_pop_order_by : Mixen_stddev_pop_order_by -> Value
encodeMixen_stddev_pop_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildMixen_stddev_samp_order_by :
    (Mixen_stddev_samp_order_byOptionalFields -> Mixen_stddev_samp_order_byOptionalFields)
    -> Mixen_stddev_samp_order_by
buildMixen_stddev_samp_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Mixen_stddev_samp_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Mixen\_stddev\_samp\_order\_by input object.
-}
type alias Mixen_stddev_samp_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Mixen\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeMixen_stddev_samp_order_by : Mixen_stddev_samp_order_by -> Value
encodeMixen_stddev_samp_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildMixen_stream_cursor_input :
    Mixen_stream_cursor_inputRequiredFields
    -> (Mixen_stream_cursor_inputOptionalFields -> Mixen_stream_cursor_inputOptionalFields)
    -> Mixen_stream_cursor_input
buildMixen_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Mixen_stream_cursor_inputRequiredFields =
    { initial_value : Mixen_stream_cursor_value_input }


type alias Mixen_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Dphones.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Mixen\_stream\_cursor\_input input object.
-}
type alias Mixen_stream_cursor_input =
    { initial_value : Mixen_stream_cursor_value_input
    , ordering : OptionalArgument Dphones.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Mixen\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeMixen_stream_cursor_input : Mixen_stream_cursor_input -> Value
encodeMixen_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeMixen_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Dphones.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildMixen_stream_cursor_value_input :
    (Mixen_stream_cursor_value_inputOptionalFields -> Mixen_stream_cursor_value_inputOptionalFields)
    -> Mixen_stream_cursor_value_input
buildMixen_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, list = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { index = optionals____.index, list = optionals____.list, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Mixen_stream_cursor_value_inputOptionalFields =
    { index : OptionalArgument Int
    , list : OptionalArgument String
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Type for the Mixen\_stream\_cursor\_value\_input input object.
-}
type alias Mixen_stream_cursor_value_input =
    { index : OptionalArgument Int
    , list : OptionalArgument String
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Encode a Mixen\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeMixen_stream_cursor_value_input : Mixen_stream_cursor_value_input -> Value
encodeMixen_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "index", Encode.int |> Encode.optional input____.index ), ( "list", Encode.string |> Encode.optional input____.list ), ( "plays", Encode.int |> Encode.optional input____.plays ), ( "title", Encode.string |> Encode.optional input____.title ), ( "url", Encode.string |> Encode.optional input____.url ) ]


buildMixen_sum_order_by :
    (Mixen_sum_order_byOptionalFields -> Mixen_sum_order_byOptionalFields)
    -> Mixen_sum_order_by
buildMixen_sum_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Mixen_sum_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Mixen\_sum\_order\_by input object.
-}
type alias Mixen_sum_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Mixen\_sum\_order\_by into a value that can be used as an argument.
-}
encodeMixen_sum_order_by : Mixen_sum_order_by -> Value
encodeMixen_sum_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildMixen_updates :
    Mixen_updatesRequiredFields
    -> (Mixen_updatesOptionalFields -> Mixen_updatesOptionalFields)
    -> Mixen_updates
buildMixen_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { inc_ = Absent, set_ = Absent }
    in
    Mixen_updates { inc_ = optionals____.inc_, set_ = optionals____.set_, where_ = required____.where_ }


type alias Mixen_updatesRequiredFields =
    { where_ : Mixen_bool_exp }


type alias Mixen_updatesOptionalFields =
    { inc_ : OptionalArgument Mixen_inc_input
    , set_ : OptionalArgument Mixen_set_input
    }


{-| Type alias for the `Mixen_updates` attributes. Note that this type
needs to use the `Mixen_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Mixen_updatesRaw =
    { inc_ : OptionalArgument Mixen_inc_input
    , set_ : OptionalArgument Mixen_set_input
    , where_ : Mixen_bool_exp
    }


{-| Type for the Mixen\_updates input object.
-}
type Mixen_updates
    = Mixen_updates Mixen_updatesRaw


{-| Encode a Mixen\_updates into a value that can be used as an argument.
-}
encodeMixen_updates : Mixen_updates -> Value
encodeMixen_updates (Mixen_updates input____) =
    Encode.maybeObject
        [ ( "_inc", encodeMixen_inc_input |> Encode.optional input____.inc_ ), ( "_set", encodeMixen_set_input |> Encode.optional input____.set_ ), ( "where", encodeMixen_bool_exp input____.where_ |> Just ) ]


buildMixen_var_pop_order_by :
    (Mixen_var_pop_order_byOptionalFields -> Mixen_var_pop_order_byOptionalFields)
    -> Mixen_var_pop_order_by
buildMixen_var_pop_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Mixen_var_pop_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Mixen\_var\_pop\_order\_by input object.
-}
type alias Mixen_var_pop_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Mixen\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeMixen_var_pop_order_by : Mixen_var_pop_order_by -> Value
encodeMixen_var_pop_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildMixen_var_samp_order_by :
    (Mixen_var_samp_order_byOptionalFields -> Mixen_var_samp_order_byOptionalFields)
    -> Mixen_var_samp_order_by
buildMixen_var_samp_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Mixen_var_samp_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Mixen\_var\_samp\_order\_by input object.
-}
type alias Mixen_var_samp_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Mixen\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeMixen_var_samp_order_by : Mixen_var_samp_order_by -> Value
encodeMixen_var_samp_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildMixen_variance_order_by :
    (Mixen_variance_order_byOptionalFields -> Mixen_variance_order_byOptionalFields)
    -> Mixen_variance_order_by
buildMixen_variance_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Mixen_variance_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Mixen\_variance\_order\_by input object.
-}
type alias Mixen_variance_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Mixen\_variance\_order\_by into a value that can be used as an argument.
-}
encodeMixen_variance_order_by : Mixen_variance_order_by -> Value
encodeMixen_variance_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildSet_bool_exp :
    (Set_bool_expOptionalFields -> Set_bool_expOptionalFields)
    -> Set_bool_exp
buildSet_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, date = Absent, mixen = Absent, mixen_aggregate = Absent, tag = Absent, title = Absent }
    in
    Set_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, date = optionals____.date, mixen = optionals____.mixen, mixen_aggregate = optionals____.mixen_aggregate, tag = optionals____.tag, title = optionals____.title }


type alias Set_bool_expOptionalFields =
    { and_ : OptionalArgument (List Set_bool_exp)
    , not_ : OptionalArgument Set_bool_exp
    , or_ : OptionalArgument (List Set_bool_exp)
    , date : OptionalArgument Date_comparison_exp
    , mixen : OptionalArgument Mixen_bool_exp
    , mixen_aggregate : OptionalArgument Mixen_aggregate_bool_exp
    , tag : OptionalArgument String_comparison_exp
    , title : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Set_bool_exp` attributes. Note that this type
needs to use the `Set_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Set_bool_expRaw =
    { and_ : OptionalArgument (List Set_bool_exp)
    , not_ : OptionalArgument Set_bool_exp
    , or_ : OptionalArgument (List Set_bool_exp)
    , date : OptionalArgument Date_comparison_exp
    , mixen : OptionalArgument Mixen_bool_exp
    , mixen_aggregate : OptionalArgument Mixen_aggregate_bool_exp
    , tag : OptionalArgument String_comparison_exp
    , title : OptionalArgument String_comparison_exp
    }


{-| Type for the Set\_bool\_exp input object.
-}
type Set_bool_exp
    = Set_bool_exp Set_bool_expRaw


{-| Encode a Set\_bool\_exp into a value that can be used as an argument.
-}
encodeSet_bool_exp : Set_bool_exp -> Value
encodeSet_bool_exp (Set_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeSet_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeSet_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeSet_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "date", encodeDate_comparison_exp |> Encode.optional input____.date ), ( "mixen", encodeMixen_bool_exp |> Encode.optional input____.mixen ), ( "mixen_aggregate", encodeMixen_aggregate_bool_exp |> Encode.optional input____.mixen_aggregate ), ( "tag", encodeString_comparison_exp |> Encode.optional input____.tag ), ( "title", encodeString_comparison_exp |> Encode.optional input____.title ) ]


buildSet_insert_input :
    (Set_insert_inputOptionalFields -> Set_insert_inputOptionalFields)
    -> Set_insert_input
buildSet_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { date = Absent, mixen = Absent, tag = Absent, title = Absent }
    in
    Set_insert_input { date = optionals____.date, mixen = optionals____.mixen, tag = optionals____.tag, title = optionals____.title }


type alias Set_insert_inputOptionalFields =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , mixen : OptionalArgument Mixen_arr_rel_insert_input
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type alias for the `Set_insert_input` attributes. Note that this type
needs to use the `Set_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Set_insert_inputRaw =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , mixen : OptionalArgument Mixen_arr_rel_insert_input
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type for the Set\_insert\_input input object.
-}
type Set_insert_input
    = Set_insert_input Set_insert_inputRaw


{-| Encode a Set\_insert\_input into a value that can be used as an argument.
-}
encodeSet_insert_input : Set_insert_input -> Value
encodeSet_insert_input (Set_insert_input input____) =
    Encode.maybeObject
        [ ( "date", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.date ), ( "mixen", encodeMixen_arr_rel_insert_input |> Encode.optional input____.mixen ), ( "tag", Encode.string |> Encode.optional input____.tag ), ( "title", Encode.string |> Encode.optional input____.title ) ]


buildSet_obj_rel_insert_input :
    Set_obj_rel_insert_inputRequiredFields
    -> (Set_obj_rel_insert_inputOptionalFields -> Set_obj_rel_insert_inputOptionalFields)
    -> Set_obj_rel_insert_input
buildSet_obj_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Set_obj_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Set_obj_rel_insert_inputRequiredFields =
    { data : Set_insert_input }


type alias Set_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Set_on_conflict }


{-| Type alias for the `Set_obj_rel_insert_input` attributes. Note that this type
needs to use the `Set_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Set_obj_rel_insert_inputRaw =
    { data : Set_insert_input
    , on_conflict : OptionalArgument Set_on_conflict
    }


{-| Type for the Set\_obj\_rel\_insert\_input input object.
-}
type Set_obj_rel_insert_input
    = Set_obj_rel_insert_input Set_obj_rel_insert_inputRaw


{-| Encode a Set\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeSet_obj_rel_insert_input : Set_obj_rel_insert_input -> Value
encodeSet_obj_rel_insert_input (Set_obj_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", encodeSet_insert_input input____.data |> Just ), ( "on_conflict", encodeSet_on_conflict |> Encode.optional input____.on_conflict ) ]


buildSet_on_conflict :
    Set_on_conflictRequiredFields
    -> (Set_on_conflictOptionalFields -> Set_on_conflictOptionalFields)
    -> Set_on_conflict
buildSet_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Set_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Set_on_conflictRequiredFields =
    { constraint : Dphones.Enum.Set_constraint.Set_constraint
    , update_columns : List Dphones.Enum.Set_update_column.Set_update_column
    }


type alias Set_on_conflictOptionalFields =
    { where_ : OptionalArgument Set_bool_exp }


{-| Type alias for the `Set_on_conflict` attributes. Note that this type
needs to use the `Set_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Set_on_conflictRaw =
    { constraint : Dphones.Enum.Set_constraint.Set_constraint
    , update_columns : List Dphones.Enum.Set_update_column.Set_update_column
    , where_ : OptionalArgument Set_bool_exp
    }


{-| Type for the Set\_on\_conflict input object.
-}
type Set_on_conflict
    = Set_on_conflict Set_on_conflictRaw


{-| Encode a Set\_on\_conflict into a value that can be used as an argument.
-}
encodeSet_on_conflict : Set_on_conflict -> Value
encodeSet_on_conflict (Set_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Dphones.Enum.Set_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Dphones.Enum.Set_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeSet_bool_exp |> Encode.optional input____.where_ ) ]


buildSet_order_by :
    (Set_order_byOptionalFields -> Set_order_byOptionalFields)
    -> Set_order_by
buildSet_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { date = Absent, mixen_aggregate = Absent, tag = Absent, title = Absent }
    in
    { date = optionals____.date, mixen_aggregate = optionals____.mixen_aggregate, tag = optionals____.tag, title = optionals____.title }


type alias Set_order_byOptionalFields =
    { date : OptionalArgument Dphones.Enum.Order_by.Order_by
    , mixen_aggregate : OptionalArgument Mixen_aggregate_order_by
    , tag : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Set\_order\_by input object.
-}
type alias Set_order_by =
    { date : OptionalArgument Dphones.Enum.Order_by.Order_by
    , mixen_aggregate : OptionalArgument Mixen_aggregate_order_by
    , tag : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Set\_order\_by into a value that can be used as an argument.
-}
encodeSet_order_by : Set_order_by -> Value
encodeSet_order_by input____ =
    Encode.maybeObject
        [ ( "date", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.date ), ( "mixen_aggregate", encodeMixen_aggregate_order_by |> Encode.optional input____.mixen_aggregate ), ( "tag", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.tag ), ( "title", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.title ) ]


buildSet_pk_columns_input :
    Set_pk_columns_inputRequiredFields
    -> Set_pk_columns_input
buildSet_pk_columns_input required____ =
    { tag = required____.tag }


type alias Set_pk_columns_inputRequiredFields =
    { tag : String }


{-| Type for the Set\_pk\_columns\_input input object.
-}
type alias Set_pk_columns_input =
    { tag : String }


{-| Encode a Set\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeSet_pk_columns_input : Set_pk_columns_input -> Value
encodeSet_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "tag", Encode.string input____.tag |> Just ) ]


buildSet_set_input :
    (Set_set_inputOptionalFields -> Set_set_inputOptionalFields)
    -> Set_set_input
buildSet_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { date = Absent, tag = Absent, title = Absent }
    in
    { date = optionals____.date, tag = optionals____.tag, title = optionals____.title }


type alias Set_set_inputOptionalFields =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type for the Set\_set\_input input object.
-}
type alias Set_set_input =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Encode a Set\_set\_input into a value that can be used as an argument.
-}
encodeSet_set_input : Set_set_input -> Value
encodeSet_set_input input____ =
    Encode.maybeObject
        [ ( "date", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.date ), ( "tag", Encode.string |> Encode.optional input____.tag ), ( "title", Encode.string |> Encode.optional input____.title ) ]


buildSet_stream_cursor_input :
    Set_stream_cursor_inputRequiredFields
    -> (Set_stream_cursor_inputOptionalFields -> Set_stream_cursor_inputOptionalFields)
    -> Set_stream_cursor_input
buildSet_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Set_stream_cursor_inputRequiredFields =
    { initial_value : Set_stream_cursor_value_input }


type alias Set_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Dphones.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Set\_stream\_cursor\_input input object.
-}
type alias Set_stream_cursor_input =
    { initial_value : Set_stream_cursor_value_input
    , ordering : OptionalArgument Dphones.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Set\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeSet_stream_cursor_input : Set_stream_cursor_input -> Value
encodeSet_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeSet_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Dphones.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildSet_stream_cursor_value_input :
    (Set_stream_cursor_value_inputOptionalFields -> Set_stream_cursor_value_inputOptionalFields)
    -> Set_stream_cursor_value_input
buildSet_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { date = Absent, tag = Absent, title = Absent }
    in
    { date = optionals____.date, tag = optionals____.tag, title = optionals____.title }


type alias Set_stream_cursor_value_inputOptionalFields =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type for the Set\_stream\_cursor\_value\_input input object.
-}
type alias Set_stream_cursor_value_input =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Encode a Set\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeSet_stream_cursor_value_input : Set_stream_cursor_value_input -> Value
encodeSet_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "date", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.date ), ( "tag", Encode.string |> Encode.optional input____.tag ), ( "title", Encode.string |> Encode.optional input____.title ) ]


buildSet_updates :
    Set_updatesRequiredFields
    -> (Set_updatesOptionalFields -> Set_updatesOptionalFields)
    -> Set_updates
buildSet_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Set_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Set_updatesRequiredFields =
    { where_ : Set_bool_exp }


type alias Set_updatesOptionalFields =
    { set_ : OptionalArgument Set_set_input }


{-| Type alias for the `Set_updates` attributes. Note that this type
needs to use the `Set_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Set_updatesRaw =
    { set_ : OptionalArgument Set_set_input
    , where_ : Set_bool_exp
    }


{-| Type for the Set\_updates input object.
-}
type Set_updates
    = Set_updates Set_updatesRaw


{-| Encode a Set\_updates into a value that can be used as an argument.
-}
encodeSet_updates : Set_updates -> Value
encodeSet_updates (Set_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeSet_set_input |> Encode.optional input____.set_ ), ( "where", encodeSet_bool_exp input____.where_ |> Just ) ]


buildString_comparison_exp :
    (String_comparison_expOptionalFields -> String_comparison_expOptionalFields)
    -> String_comparison_exp
buildString_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, iregex_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, niregex_ = Absent, nlike_ = Absent, nregex_ = Absent, nsimilar_ = Absent, regex_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, ilike_ = optionals____.ilike_, in_ = optionals____.in_, iregex_ = optionals____.iregex_, is_null_ = optionals____.is_null_, like_ = optionals____.like_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nilike_ = optionals____.nilike_, nin_ = optionals____.nin_, niregex_ = optionals____.niregex_, nlike_ = optionals____.nlike_, nregex_ = optionals____.nregex_, nsimilar_ = optionals____.nsimilar_, regex_ = optionals____.regex_, similar_ = optionals____.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , iregex_ : OptionalArgument String
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , niregex_ : OptionalArgument String
    , nlike_ : OptionalArgument String
    , nregex_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , regex_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , iregex_ : OptionalArgument String
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , niregex_ : OptionalArgument String
    , nlike_ : OptionalArgument String
    , nregex_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , regex_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input____.eq_ ), ( "_gt", Encode.string |> Encode.optional input____.gt_ ), ( "_gte", Encode.string |> Encode.optional input____.gte_ ), ( "_ilike", Encode.string |> Encode.optional input____.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input____.in_ ), ( "_iregex", Encode.string |> Encode.optional input____.iregex_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_like", Encode.string |> Encode.optional input____.like_ ), ( "_lt", Encode.string |> Encode.optional input____.lt_ ), ( "_lte", Encode.string |> Encode.optional input____.lte_ ), ( "_neq", Encode.string |> Encode.optional input____.neq_ ), ( "_nilike", Encode.string |> Encode.optional input____.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input____.nin_ ), ( "_niregex", Encode.string |> Encode.optional input____.niregex_ ), ( "_nlike", Encode.string |> Encode.optional input____.nlike_ ), ( "_nregex", Encode.string |> Encode.optional input____.nregex_ ), ( "_nsimilar", Encode.string |> Encode.optional input____.nsimilar_ ), ( "_regex", Encode.string |> Encode.optional input____.regex_ ), ( "_similar", Encode.string |> Encode.optional input____.similar_ ) ]


buildTrack_aggregate_bool_exp :
    (Track_aggregate_bool_expOptionalFields -> Track_aggregate_bool_expOptionalFields)
    -> Track_aggregate_bool_exp
buildTrack_aggregate_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { count = Absent }
    in
    Track_aggregate_bool_exp { count = optionals____.count }


type alias Track_aggregate_bool_expOptionalFields =
    { count : OptionalArgument Track_aggregate_bool_exp_count }


{-| Type alias for the `Track_aggregate_bool_exp` attributes. Note that this type
needs to use the `Track_aggregate_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Track_aggregate_bool_expRaw =
    { count : OptionalArgument Track_aggregate_bool_exp_count }


{-| Type for the Track\_aggregate\_bool\_exp input object.
-}
type Track_aggregate_bool_exp
    = Track_aggregate_bool_exp Track_aggregate_bool_expRaw


{-| Encode a Track\_aggregate\_bool\_exp into a value that can be used as an argument.
-}
encodeTrack_aggregate_bool_exp : Track_aggregate_bool_exp -> Value
encodeTrack_aggregate_bool_exp (Track_aggregate_bool_exp input____) =
    Encode.maybeObject
        [ ( "count", encodeTrack_aggregate_bool_exp_count |> Encode.optional input____.count ) ]


buildTrack_aggregate_bool_exp_count :
    Track_aggregate_bool_exp_countRequiredFields
    -> (Track_aggregate_bool_exp_countOptionalFields -> Track_aggregate_bool_exp_countOptionalFields)
    -> Track_aggregate_bool_exp_count
buildTrack_aggregate_bool_exp_count required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { arguments = Absent, distinct = Absent, filter = Absent }
    in
    Track_aggregate_bool_exp_count { arguments = optionals____.arguments, distinct = optionals____.distinct, filter = optionals____.filter, predicate = required____.predicate }


type alias Track_aggregate_bool_exp_countRequiredFields =
    { predicate : Int_comparison_exp }


type alias Track_aggregate_bool_exp_countOptionalFields =
    { arguments : OptionalArgument (List Dphones.Enum.Track_select_column.Track_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Track_bool_exp
    }


{-| Type alias for the `Track_aggregate_bool_exp_count` attributes. Note that this type
needs to use the `Track_aggregate_bool_exp_count` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Track_aggregate_bool_exp_countRaw =
    { arguments : OptionalArgument (List Dphones.Enum.Track_select_column.Track_select_column)
    , distinct : OptionalArgument Bool
    , filter : OptionalArgument Track_bool_exp
    , predicate : Int_comparison_exp
    }


{-| Type for the Track\_aggregate\_bool\_exp\_count input object.
-}
type Track_aggregate_bool_exp_count
    = Track_aggregate_bool_exp_count Track_aggregate_bool_exp_countRaw


{-| Encode a Track\_aggregate\_bool\_exp\_count into a value that can be used as an argument.
-}
encodeTrack_aggregate_bool_exp_count : Track_aggregate_bool_exp_count -> Value
encodeTrack_aggregate_bool_exp_count (Track_aggregate_bool_exp_count input____) =
    Encode.maybeObject
        [ ( "arguments", (Encode.enum Dphones.Enum.Track_select_column.toString |> Encode.list) |> Encode.optional input____.arguments ), ( "distinct", Encode.bool |> Encode.optional input____.distinct ), ( "filter", encodeTrack_bool_exp |> Encode.optional input____.filter ), ( "predicate", encodeInt_comparison_exp input____.predicate |> Just ) ]


buildTrack_aggregate_order_by :
    (Track_aggregate_order_byOptionalFields -> Track_aggregate_order_byOptionalFields)
    -> Track_aggregate_order_by
buildTrack_aggregate_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals____.avg, count = optionals____.count, max = optionals____.max, min = optionals____.min, stddev = optionals____.stddev, stddev_pop = optionals____.stddev_pop, stddev_samp = optionals____.stddev_samp, sum = optionals____.sum, var_pop = optionals____.var_pop, var_samp = optionals____.var_samp, variance = optionals____.variance }


type alias Track_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Track_avg_order_by
    , count : OptionalArgument Dphones.Enum.Order_by.Order_by
    , max : OptionalArgument Track_max_order_by
    , min : OptionalArgument Track_min_order_by
    , stddev : OptionalArgument Track_stddev_order_by
    , stddev_pop : OptionalArgument Track_stddev_pop_order_by
    , stddev_samp : OptionalArgument Track_stddev_samp_order_by
    , sum : OptionalArgument Track_sum_order_by
    , var_pop : OptionalArgument Track_var_pop_order_by
    , var_samp : OptionalArgument Track_var_samp_order_by
    , variance : OptionalArgument Track_variance_order_by
    }


{-| Type for the Track\_aggregate\_order\_by input object.
-}
type alias Track_aggregate_order_by =
    { avg : OptionalArgument Track_avg_order_by
    , count : OptionalArgument Dphones.Enum.Order_by.Order_by
    , max : OptionalArgument Track_max_order_by
    , min : OptionalArgument Track_min_order_by
    , stddev : OptionalArgument Track_stddev_order_by
    , stddev_pop : OptionalArgument Track_stddev_pop_order_by
    , stddev_samp : OptionalArgument Track_stddev_samp_order_by
    , sum : OptionalArgument Track_sum_order_by
    , var_pop : OptionalArgument Track_var_pop_order_by
    , var_samp : OptionalArgument Track_var_samp_order_by
    , variance : OptionalArgument Track_variance_order_by
    }


{-| Encode a Track\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeTrack_aggregate_order_by : Track_aggregate_order_by -> Value
encodeTrack_aggregate_order_by input____ =
    Encode.maybeObject
        [ ( "avg", encodeTrack_avg_order_by |> Encode.optional input____.avg ), ( "count", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.count ), ( "max", encodeTrack_max_order_by |> Encode.optional input____.max ), ( "min", encodeTrack_min_order_by |> Encode.optional input____.min ), ( "stddev", encodeTrack_stddev_order_by |> Encode.optional input____.stddev ), ( "stddev_pop", encodeTrack_stddev_pop_order_by |> Encode.optional input____.stddev_pop ), ( "stddev_samp", encodeTrack_stddev_samp_order_by |> Encode.optional input____.stddev_samp ), ( "sum", encodeTrack_sum_order_by |> Encode.optional input____.sum ), ( "var_pop", encodeTrack_var_pop_order_by |> Encode.optional input____.var_pop ), ( "var_samp", encodeTrack_var_samp_order_by |> Encode.optional input____.var_samp ), ( "variance", encodeTrack_variance_order_by |> Encode.optional input____.variance ) ]


buildTrack_arr_rel_insert_input :
    Track_arr_rel_insert_inputRequiredFields
    -> (Track_arr_rel_insert_inputOptionalFields -> Track_arr_rel_insert_inputOptionalFields)
    -> Track_arr_rel_insert_input
buildTrack_arr_rel_insert_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { on_conflict = Absent }
    in
    Track_arr_rel_insert_input { data = required____.data, on_conflict = optionals____.on_conflict }


type alias Track_arr_rel_insert_inputRequiredFields =
    { data : List Track_insert_input }


type alias Track_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Track_on_conflict }


{-| Type alias for the `Track_arr_rel_insert_input` attributes. Note that this type
needs to use the `Track_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Track_arr_rel_insert_inputRaw =
    { data : List Track_insert_input
    , on_conflict : OptionalArgument Track_on_conflict
    }


{-| Type for the Track\_arr\_rel\_insert\_input input object.
-}
type Track_arr_rel_insert_input
    = Track_arr_rel_insert_input Track_arr_rel_insert_inputRaw


{-| Encode a Track\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTrack_arr_rel_insert_input : Track_arr_rel_insert_input -> Value
encodeTrack_arr_rel_insert_input (Track_arr_rel_insert_input input____) =
    Encode.maybeObject
        [ ( "data", (encodeTrack_insert_input |> Encode.list) input____.data |> Just ), ( "on_conflict", encodeTrack_on_conflict |> Encode.optional input____.on_conflict ) ]


buildTrack_avg_order_by :
    (Track_avg_order_byOptionalFields -> Track_avg_order_byOptionalFields)
    -> Track_avg_order_by
buildTrack_avg_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Track_avg_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Track\_avg\_order\_by input object.
-}
type alias Track_avg_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Track\_avg\_order\_by into a value that can be used as an argument.
-}
encodeTrack_avg_order_by : Track_avg_order_by -> Value
encodeTrack_avg_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildTrack_bool_exp :
    (Track_bool_expOptionalFields -> Track_bool_expOptionalFields)
    -> Track_bool_exp
buildTrack_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, album = Absent, appearsOn = Absent, index = Absent, plays = Absent, title = Absent, url = Absent }
    in
    Track_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, album = optionals____.album, appearsOn = optionals____.appearsOn, index = optionals____.index, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Track_bool_expOptionalFields =
    { and_ : OptionalArgument (List Track_bool_exp)
    , not_ : OptionalArgument Track_bool_exp
    , or_ : OptionalArgument (List Track_bool_exp)
    , album : OptionalArgument String_comparison_exp
    , appearsOn : OptionalArgument Album_bool_exp
    , index : OptionalArgument Int_comparison_exp
    , plays : OptionalArgument Int_comparison_exp
    , title : OptionalArgument String_comparison_exp
    , url : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Track_bool_exp` attributes. Note that this type
needs to use the `Track_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Track_bool_expRaw =
    { and_ : OptionalArgument (List Track_bool_exp)
    , not_ : OptionalArgument Track_bool_exp
    , or_ : OptionalArgument (List Track_bool_exp)
    , album : OptionalArgument String_comparison_exp
    , appearsOn : OptionalArgument Album_bool_exp
    , index : OptionalArgument Int_comparison_exp
    , plays : OptionalArgument Int_comparison_exp
    , title : OptionalArgument String_comparison_exp
    , url : OptionalArgument String_comparison_exp
    }


{-| Type for the Track\_bool\_exp input object.
-}
type Track_bool_exp
    = Track_bool_exp Track_bool_expRaw


{-| Encode a Track\_bool\_exp into a value that can be used as an argument.
-}
encodeTrack_bool_exp : Track_bool_exp -> Value
encodeTrack_bool_exp (Track_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeTrack_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeTrack_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeTrack_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "album", encodeString_comparison_exp |> Encode.optional input____.album ), ( "appearsOn", encodeAlbum_bool_exp |> Encode.optional input____.appearsOn ), ( "index", encodeInt_comparison_exp |> Encode.optional input____.index ), ( "plays", encodeInt_comparison_exp |> Encode.optional input____.plays ), ( "title", encodeString_comparison_exp |> Encode.optional input____.title ), ( "url", encodeString_comparison_exp |> Encode.optional input____.url ) ]


buildTrack_inc_input :
    (Track_inc_inputOptionalFields -> Track_inc_inputOptionalFields)
    -> Track_inc_input
buildTrack_inc_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Track_inc_inputOptionalFields =
    { index : OptionalArgument Int
    , plays : OptionalArgument Int
    }


{-| Type for the Track\_inc\_input input object.
-}
type alias Track_inc_input =
    { index : OptionalArgument Int
    , plays : OptionalArgument Int
    }


{-| Encode a Track\_inc\_input into a value that can be used as an argument.
-}
encodeTrack_inc_input : Track_inc_input -> Value
encodeTrack_inc_input input____ =
    Encode.maybeObject
        [ ( "index", Encode.int |> Encode.optional input____.index ), ( "plays", Encode.int |> Encode.optional input____.plays ) ]


buildTrack_insert_input :
    (Track_insert_inputOptionalFields -> Track_insert_inputOptionalFields)
    -> Track_insert_input
buildTrack_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { album = Absent, appearsOn = Absent, index = Absent, plays = Absent, title = Absent, url = Absent }
    in
    Track_insert_input { album = optionals____.album, appearsOn = optionals____.appearsOn, index = optionals____.index, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Track_insert_inputOptionalFields =
    { album : OptionalArgument String
    , appearsOn : OptionalArgument Album_obj_rel_insert_input
    , index : OptionalArgument Int
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Type alias for the `Track_insert_input` attributes. Note that this type
needs to use the `Track_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Track_insert_inputRaw =
    { album : OptionalArgument String
    , appearsOn : OptionalArgument Album_obj_rel_insert_input
    , index : OptionalArgument Int
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Type for the Track\_insert\_input input object.
-}
type Track_insert_input
    = Track_insert_input Track_insert_inputRaw


{-| Encode a Track\_insert\_input into a value that can be used as an argument.
-}
encodeTrack_insert_input : Track_insert_input -> Value
encodeTrack_insert_input (Track_insert_input input____) =
    Encode.maybeObject
        [ ( "album", Encode.string |> Encode.optional input____.album ), ( "appearsOn", encodeAlbum_obj_rel_insert_input |> Encode.optional input____.appearsOn ), ( "index", Encode.int |> Encode.optional input____.index ), ( "plays", Encode.int |> Encode.optional input____.plays ), ( "title", Encode.string |> Encode.optional input____.title ), ( "url", Encode.string |> Encode.optional input____.url ) ]


buildTrack_max_order_by :
    (Track_max_order_byOptionalFields -> Track_max_order_byOptionalFields)
    -> Track_max_order_by
buildTrack_max_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { album = Absent, index = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { album = optionals____.album, index = optionals____.index, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Track_max_order_byOptionalFields =
    { album : OptionalArgument Dphones.Enum.Order_by.Order_by
    , index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Track\_max\_order\_by input object.
-}
type alias Track_max_order_by =
    { album : OptionalArgument Dphones.Enum.Order_by.Order_by
    , index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Track\_max\_order\_by into a value that can be used as an argument.
-}
encodeTrack_max_order_by : Track_max_order_by -> Value
encodeTrack_max_order_by input____ =
    Encode.maybeObject
        [ ( "album", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.album ), ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ), ( "title", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.title ), ( "url", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.url ) ]


buildTrack_min_order_by :
    (Track_min_order_byOptionalFields -> Track_min_order_byOptionalFields)
    -> Track_min_order_by
buildTrack_min_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { album = Absent, index = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { album = optionals____.album, index = optionals____.index, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Track_min_order_byOptionalFields =
    { album : OptionalArgument Dphones.Enum.Order_by.Order_by
    , index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Track\_min\_order\_by input object.
-}
type alias Track_min_order_by =
    { album : OptionalArgument Dphones.Enum.Order_by.Order_by
    , index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Track\_min\_order\_by into a value that can be used as an argument.
-}
encodeTrack_min_order_by : Track_min_order_by -> Value
encodeTrack_min_order_by input____ =
    Encode.maybeObject
        [ ( "album", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.album ), ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ), ( "title", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.title ), ( "url", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.url ) ]


buildTrack_on_conflict :
    Track_on_conflictRequiredFields
    -> (Track_on_conflictOptionalFields -> Track_on_conflictOptionalFields)
    -> Track_on_conflict
buildTrack_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Track_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Track_on_conflictRequiredFields =
    { constraint : Dphones.Enum.Track_constraint.Track_constraint
    , update_columns : List Dphones.Enum.Track_update_column.Track_update_column
    }


type alias Track_on_conflictOptionalFields =
    { where_ : OptionalArgument Track_bool_exp }


{-| Type alias for the `Track_on_conflict` attributes. Note that this type
needs to use the `Track_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Track_on_conflictRaw =
    { constraint : Dphones.Enum.Track_constraint.Track_constraint
    , update_columns : List Dphones.Enum.Track_update_column.Track_update_column
    , where_ : OptionalArgument Track_bool_exp
    }


{-| Type for the Track\_on\_conflict input object.
-}
type Track_on_conflict
    = Track_on_conflict Track_on_conflictRaw


{-| Encode a Track\_on\_conflict into a value that can be used as an argument.
-}
encodeTrack_on_conflict : Track_on_conflict -> Value
encodeTrack_on_conflict (Track_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Dphones.Enum.Track_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Dphones.Enum.Track_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeTrack_bool_exp |> Encode.optional input____.where_ ) ]


buildTrack_order_by :
    (Track_order_byOptionalFields -> Track_order_byOptionalFields)
    -> Track_order_by
buildTrack_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { album = Absent, appearsOn = Absent, index = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { album = optionals____.album, appearsOn = optionals____.appearsOn, index = optionals____.index, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Track_order_byOptionalFields =
    { album : OptionalArgument Dphones.Enum.Order_by.Order_by
    , appearsOn : OptionalArgument Album_order_by
    , index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Track\_order\_by input object.
-}
type alias Track_order_by =
    { album : OptionalArgument Dphones.Enum.Order_by.Order_by
    , appearsOn : OptionalArgument Album_order_by
    , index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Track\_order\_by into a value that can be used as an argument.
-}
encodeTrack_order_by : Track_order_by -> Value
encodeTrack_order_by input____ =
    Encode.maybeObject
        [ ( "album", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.album ), ( "appearsOn", encodeAlbum_order_by |> Encode.optional input____.appearsOn ), ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ), ( "title", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.title ), ( "url", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.url ) ]


buildTrack_pk_columns_input :
    Track_pk_columns_inputRequiredFields
    -> Track_pk_columns_input
buildTrack_pk_columns_input required____ =
    { url = required____.url }


type alias Track_pk_columns_inputRequiredFields =
    { url : String }


{-| Type for the Track\_pk\_columns\_input input object.
-}
type alias Track_pk_columns_input =
    { url : String }


{-| Encode a Track\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeTrack_pk_columns_input : Track_pk_columns_input -> Value
encodeTrack_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "url", Encode.string input____.url |> Just ) ]


buildTrack_set_input :
    (Track_set_inputOptionalFields -> Track_set_inputOptionalFields)
    -> Track_set_input
buildTrack_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { album = Absent, index = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { album = optionals____.album, index = optionals____.index, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Track_set_inputOptionalFields =
    { album : OptionalArgument String
    , index : OptionalArgument Int
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Type for the Track\_set\_input input object.
-}
type alias Track_set_input =
    { album : OptionalArgument String
    , index : OptionalArgument Int
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Encode a Track\_set\_input into a value that can be used as an argument.
-}
encodeTrack_set_input : Track_set_input -> Value
encodeTrack_set_input input____ =
    Encode.maybeObject
        [ ( "album", Encode.string |> Encode.optional input____.album ), ( "index", Encode.int |> Encode.optional input____.index ), ( "plays", Encode.int |> Encode.optional input____.plays ), ( "title", Encode.string |> Encode.optional input____.title ), ( "url", Encode.string |> Encode.optional input____.url ) ]


buildTrack_stddev_order_by :
    (Track_stddev_order_byOptionalFields -> Track_stddev_order_byOptionalFields)
    -> Track_stddev_order_by
buildTrack_stddev_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Track_stddev_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Track\_stddev\_order\_by input object.
-}
type alias Track_stddev_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Track\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeTrack_stddev_order_by : Track_stddev_order_by -> Value
encodeTrack_stddev_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildTrack_stddev_pop_order_by :
    (Track_stddev_pop_order_byOptionalFields -> Track_stddev_pop_order_byOptionalFields)
    -> Track_stddev_pop_order_by
buildTrack_stddev_pop_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Track_stddev_pop_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Track\_stddev\_pop\_order\_by input object.
-}
type alias Track_stddev_pop_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Track\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeTrack_stddev_pop_order_by : Track_stddev_pop_order_by -> Value
encodeTrack_stddev_pop_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildTrack_stddev_samp_order_by :
    (Track_stddev_samp_order_byOptionalFields -> Track_stddev_samp_order_byOptionalFields)
    -> Track_stddev_samp_order_by
buildTrack_stddev_samp_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Track_stddev_samp_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Track\_stddev\_samp\_order\_by input object.
-}
type alias Track_stddev_samp_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Track\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeTrack_stddev_samp_order_by : Track_stddev_samp_order_by -> Value
encodeTrack_stddev_samp_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildTrack_stream_cursor_input :
    Track_stream_cursor_inputRequiredFields
    -> (Track_stream_cursor_inputOptionalFields -> Track_stream_cursor_inputOptionalFields)
    -> Track_stream_cursor_input
buildTrack_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Track_stream_cursor_inputRequiredFields =
    { initial_value : Track_stream_cursor_value_input }


type alias Track_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Dphones.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Track\_stream\_cursor\_input input object.
-}
type alias Track_stream_cursor_input =
    { initial_value : Track_stream_cursor_value_input
    , ordering : OptionalArgument Dphones.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Track\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeTrack_stream_cursor_input : Track_stream_cursor_input -> Value
encodeTrack_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeTrack_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Dphones.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildTrack_stream_cursor_value_input :
    (Track_stream_cursor_value_inputOptionalFields -> Track_stream_cursor_value_inputOptionalFields)
    -> Track_stream_cursor_value_input
buildTrack_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { album = Absent, index = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { album = optionals____.album, index = optionals____.index, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Track_stream_cursor_value_inputOptionalFields =
    { album : OptionalArgument String
    , index : OptionalArgument Int
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Type for the Track\_stream\_cursor\_value\_input input object.
-}
type alias Track_stream_cursor_value_input =
    { album : OptionalArgument String
    , index : OptionalArgument Int
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Encode a Track\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeTrack_stream_cursor_value_input : Track_stream_cursor_value_input -> Value
encodeTrack_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "album", Encode.string |> Encode.optional input____.album ), ( "index", Encode.int |> Encode.optional input____.index ), ( "plays", Encode.int |> Encode.optional input____.plays ), ( "title", Encode.string |> Encode.optional input____.title ), ( "url", Encode.string |> Encode.optional input____.url ) ]


buildTrack_sum_order_by :
    (Track_sum_order_byOptionalFields -> Track_sum_order_byOptionalFields)
    -> Track_sum_order_by
buildTrack_sum_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Track_sum_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Track\_sum\_order\_by input object.
-}
type alias Track_sum_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Track\_sum\_order\_by into a value that can be used as an argument.
-}
encodeTrack_sum_order_by : Track_sum_order_by -> Value
encodeTrack_sum_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildTrack_updates :
    Track_updatesRequiredFields
    -> (Track_updatesOptionalFields -> Track_updatesOptionalFields)
    -> Track_updates
buildTrack_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { inc_ = Absent, set_ = Absent }
    in
    Track_updates { inc_ = optionals____.inc_, set_ = optionals____.set_, where_ = required____.where_ }


type alias Track_updatesRequiredFields =
    { where_ : Track_bool_exp }


type alias Track_updatesOptionalFields =
    { inc_ : OptionalArgument Track_inc_input
    , set_ : OptionalArgument Track_set_input
    }


{-| Type alias for the `Track_updates` attributes. Note that this type
needs to use the `Track_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Track_updatesRaw =
    { inc_ : OptionalArgument Track_inc_input
    , set_ : OptionalArgument Track_set_input
    , where_ : Track_bool_exp
    }


{-| Type for the Track\_updates input object.
-}
type Track_updates
    = Track_updates Track_updatesRaw


{-| Encode a Track\_updates into a value that can be used as an argument.
-}
encodeTrack_updates : Track_updates -> Value
encodeTrack_updates (Track_updates input____) =
    Encode.maybeObject
        [ ( "_inc", encodeTrack_inc_input |> Encode.optional input____.inc_ ), ( "_set", encodeTrack_set_input |> Encode.optional input____.set_ ), ( "where", encodeTrack_bool_exp input____.where_ |> Just ) ]


buildTrack_var_pop_order_by :
    (Track_var_pop_order_byOptionalFields -> Track_var_pop_order_byOptionalFields)
    -> Track_var_pop_order_by
buildTrack_var_pop_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Track_var_pop_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Track\_var\_pop\_order\_by input object.
-}
type alias Track_var_pop_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Track\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeTrack_var_pop_order_by : Track_var_pop_order_by -> Value
encodeTrack_var_pop_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildTrack_var_samp_order_by :
    (Track_var_samp_order_byOptionalFields -> Track_var_samp_order_byOptionalFields)
    -> Track_var_samp_order_by
buildTrack_var_samp_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Track_var_samp_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Track\_var\_samp\_order\_by input object.
-}
type alias Track_var_samp_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Track\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeTrack_var_samp_order_by : Track_var_samp_order_by -> Value
encodeTrack_var_samp_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]


buildTrack_variance_order_by :
    (Track_variance_order_byOptionalFields -> Track_variance_order_byOptionalFields)
    -> Track_variance_order_by
buildTrack_variance_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Track_variance_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Track\_variance\_order\_by input object.
-}
type alias Track_variance_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Track\_variance\_order\_by into a value that can be used as an argument.
-}
encodeTrack_variance_order_by : Track_variance_order_by -> Value
encodeTrack_variance_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ) ]
